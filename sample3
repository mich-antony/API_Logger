To enhance the api_tracker package by including UUID-based request ID, correlation ID, and track ID in the design, we’ll update the database schema, SQLAlchemy models, FastAPI middleware, logging strategies, and related components. These identifiers serve distinct purposes:
	•	Request ID: A unique identifier for each individual request, generated by the server.
	•	Correlation ID: An identifier passed by the client (e.g., via a header like X-Correlation-ID) to link related requests across systems or services.
	•	Track ID: A custom identifier (e.g., for tracking a request through multiple internal processing steps), which could be generated or passed by the client.
Below, I’ll integrate these into the existing design with separate tables for request_body and response_body, keeping all other features intact (Strategy Pattern, sanitization, exclusion, configurable logging).

Updated Design Overview
	1	Add Columns:
	◦	request_id (UUID) in api_logs: A server-generated unique ID for each request.
	◦	correlation_id (UUID or string) in api_logs: A client-provided ID, optional.
	◦	track_id (UUID or string) in api_logs: A custom tracking ID, optional.
	2	Generate UUIDs:
	◦	Use Python’s uuid module to generate request_id server-side.
	◦	Extract correlation_id and track_id from request headers (e.g., X-Correlation-ID, X-Track-ID), falling back to null if not provided.
	3	Propagate IDs:
	◦	Include these IDs in logs (database and file) and optionally in response headers for traceability.

Updated Rerunnable DDL Script
Add the new columns to api_logs with appropriate data types (Oracle’s RAW(16) for UUIDs or VARCHAR2 for flexibility).
-- Drop sequences if they exist
BEGIN
   EXECUTE IMMEDIATE 'DROP SEQUENCE api_log_id_seq';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -2289 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP SEQUENCE request_body_id_seq';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -2289 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP SEQUENCE response_body_id_seq';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -2289 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP SEQUENCE user_id_seq';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -2289 THEN RAISE; END IF;
END;
/

-- Drop tables if they exist
BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE request_bodies CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE response_bodies CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE api_logs CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN RAISE; END IF;
END;
/

BEGIN
   EXECUTE IMMEDIATE 'DROP TABLE users CASCADE CONSTRAINTS';
EXCEPTION
   WHEN OTHERS THEN
      IF SQLCODE != -942 THEN RAISE; END IF;
END;
/

-- Create sequences
CREATE SEQUENCE api_log_id_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE request_body_id_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE response_body_id_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE user_id_seq START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

-- Create tables
CREATE TABLE users (
   id NUMBER(19,0) DEFAULT user_id_seq.NEXTVAL,
   username VARCHAR2(50) NOT NULL,
   CONSTRAINT pk_users PRIMARY KEY (id)
);

COMMENT ON TABLE users IS 'Stores authenticated user information for linking to API logs.';
COMMENT ON COLUMN users.id IS 'Unique identifier for each user, auto-incremented.';
COMMENT ON COLUMN users.username IS 'Username of the authenticated user, required.';

CREATE TABLE api_logs (
   id NUMBER(19,0) DEFAULT api_log_id_seq.NEXTVAL,
   request_id RAW(16) NOT NULL, -- UUID for unique request identification
   correlation_id VARCHAR2(36), -- UUID or string from client, optional
   track_id VARCHAR2(50),       -- Custom tracking ID, optional
   request_method VARCHAR2(10) NOT NULL,
   request_url VARCHAR2(255) NOT NULL,
   request_headers CLOB,
   response_status NUMBER(10,0),
   response_headers CLOB,
   client_ip VARCHAR2(45) NOT NULL,
   request_time DATE DEFAULT SYSDATE NOT NULL,
   response_time DATE,
   execution_time_ms NUMBER(10,0),
   user_id NUMBER(19,0),
   error_message CLOB,
   CONSTRAINT pk_api_logs PRIMARY KEY (id),
   CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL,
   CONSTRAINT uk_request_id UNIQUE (request_id) -- Ensure request_id is unique
);

COMMENT ON TABLE api_logs IS 'Stores metadata for API requests and responses.';
COMMENT ON COLUMN api_logs.id IS 'Unique identifier for each log entry, auto-incremented.';
COMMENT ON COLUMN api_logs.request_id IS 'Server-generated UUID for each request, unique.';
COMMENT ON COLUMN api_logs.correlation_id IS 'Client-provided UUID or string to correlate requests across systems.';
COMMENT ON COLUMN api_logs.track_id IS 'Custom tracking ID for internal request tracking.';
COMMENT ON COLUMN api_logs.request_method IS 'HTTP method (e.g., GET, POST), required.';
COMMENT ON COLUMN api_logs.request_url IS 'API endpoint URL (e.g., /api/users), required.';
COMMENT ON COLUMN api_logs.request_headers IS 'JSON string of request headers, optional.';
COMMENT ON COLUMN api_logs.response_status IS 'HTTP status code (e.g., 200, 404), set after response.';
COMMENT ON COLUMN api_logs.response_headers IS 'JSON string of response headers, set after response.';
COMMENT ON COLUMN api_logs.client_ip IS 'Client IP address (IPv4/IPv6), required.';
COMMENT ON COLUMN api_logs.request_time IS 'Timestamp of request receipt, defaults to current time.';
COMMENT ON COLUMN api_logs.response_time IS 'Timestamp of response sent, null until response.';
COMMENT ON COLUMN api_logs.execution_time_ms IS 'Processing time in milliseconds, set after response.';
COMMENT ON COLUMN api_logs.user_id IS 'Foreign key to users table, null if unauthenticated.';
COMMENT ON COLUMN api_logs.error_message IS 'Error details if request failed, optional.';

CREATE TABLE request_bodies (
   id NUMBER(19,0) DEFAULT request_body_id_seq.NEXTVAL,
   api_log_id NUMBER(19,0) NOT NULL,
   body CLOB,
   CONSTRAINT pk_request_bodies PRIMARY KEY (id),
   CONSTRAINT fk_api_log_request FOREIGN KEY (api_log_id) REFERENCES api_logs(id) ON DELETE CASCADE
);

COMMENT ON TABLE request_bodies IS 'Stores request payloads linked to api_logs.';
COMMENT ON COLUMN request_bodies.id IS 'Unique identifier for each request body, auto-incremented.';
COMMENT ON COLUMN request_bodies.api_log_id IS 'Foreign key linking to api_logs, required.';
COMMENT ON COLUMN request_bodies.body IS 'Request payload (e.g., JSON), optional.';

CREATE TABLE response_bodies (
   id NUMBER(19,0) DEFAULT response_body_id_seq.NEXTVAL,
   api_log_id NUMBER(19,0) NOT NULL,
   body CLOB,
   CONSTRAINT pk_response_bodies PRIMARY KEY (id),
   CONSTRAINT fk_api_log_response FOREIGN KEY (api_log_id) REFERENCES api_logs(id) ON DELETE CASCADE
);

COMMENT ON TABLE response_bodies IS 'Stores response payloads linked to api_logs.';
COMMENT ON COLUMN response_bodies.id IS 'Unique identifier for each response body, auto-incremented.';
COMMENT ON COLUMN response_bodies.api_log_id IS 'Foreign key linking to api_logs, required.';
COMMENT ON COLUMN response_bodies.body IS 'Response payload (e.g., JSON), optional.';
Changes:
	•	Added request_id RAW(16) NOT NULL (Oracle’s binary UUID type, 16 bytes).
	•	Added correlation_id VARCHAR2(36) (36 chars for UUID string, nullable).
	•	Added track_id VARCHAR2(50) (arbitrary length for flexibility, nullable).
	•	Added CONSTRAINT uk_request_id UNIQUE (request_id) to ensure uniqueness.

Updated Python Code
1. `api_tracker/models.py`
Add the new columns to the APILog model.
from sqlalchemy import Column, Integer, String, Text, DateTime, BigInteger, ForeignKey, Sequence, BINARY
from sqlalchemy.sql import func
from .database import Base

api_log_seq = Sequence('api_log_id_seq')
request_body_seq = Sequence('request_body_id_seq')
response_body_seq = Sequence('response_body_id_seq')
user_seq = Sequence('user_id_seq')

class APILog(Base):
    __tablename__ = "api_logs"

    id = Column(BigInteger, api_log_seq, primary_key=True, server_default=api_log_seq.next_value())
    request_id = Column(BINARY(16), nullable=False, unique=True)  # UUID as binary
    correlation_id = Column(String(36), nullable=True)  # UUID string
    track_id = Column(String(50), nullable=True)  # Custom tracking ID
    request_method = Column(String(10), nullable=False)
    request_url = Column(String(255), nullable=False)
    request_headers = Column(Text, nullable=True)
    response_status = Column(Integer, nullable=True)
    response_headers = Column(Text, nullable=True)
    client_ip = Column(String(45), nullable=False)
    request_time = Column(DateTime, nullable=False, server_default=func.sysdate())
    response_time = Column(DateTime, nullable=True)
    execution_time_ms = Column(Integer, nullable=True)
    user_id = Column(BigInteger, ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    error_message = Column(Text, nullable=True)

class RequestBody(Base):
    __tablename__ = "request_bodies"
    id = Column(BigInteger, request_body_seq, primary_key=True, server_default=request_body_seq.next_value())
    api_log_id = Column(BigInteger, ForeignKey("api_logs.id", ondelete="CASCADE"), nullable=False)
    body = Column(Text, nullable=True)

class ResponseBody(Base):
    __tablename__ = "response_bodies"
    id = Column(BigInteger, response_body_seq, primary_key=True, server_default=response_body_seq.next_value())
    api_log_id = Column(BigInteger, ForeignKey("api_logs.id", ondelete="CASCADE"), nullable=False)
    body = Column(Text, nullable=True)

class User(Base):
    __tablename__ = "users"
    id = Column(BigInteger, user_seq, primary_key=True, server_default=user_seq.next_value())
    username = Column(String(50), nullable=False)
Changes:
	•	Added request_id, correlation_id, and track_id with appropriate types (BINARY(16) for UUID, String for flexibility).
2. `api_tracker/main.py`
Update the middleware to generate request_id, extract correlation_id and track_id, and include them in logs and response headers.
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from sqlalchemy.orm import Session
from .database import get_db
from .config import settings
from .sanitizer import sanitize_data
from .logging_strategies import LoggingContext
import time
import json
from datetime import datetime
import uuid

def add_api_logging_middleware(app: FastAPI):
    @app.middleware("http")
    async def log_api_requests(request: Request, call_next):
        request_path = str(request.url.path)
        if request_path in settings.EXCLUDED_PATHS:
            return await call_next(request)

        start_time = time.time()
        db = next(get_db())
        logger = LoggingContext(db)

        # Generate request_id and extract correlation_id, track_id
        request_id = uuid.uuid4()
        correlation_id = request.headers.get("X-Correlation-ID")
        track_id = request.headers.get("X-Track-ID")

        # Capture request details
        request_headers = json.dumps(dict(request.headers))
        request_body = await request.body()
        request_body_str = sanitize_data(request_body.decode("utf-8", errors="ignore") if request_body else None)
        client_ip = request.client.host

        # Log request data
        log_data = {
            "request_id": request_id.bytes,  # Store as binary
            "correlation_id": correlation_id,
            "track_id": track_id,
            "request_method": request.method,
            "request_url": request_path,
            "request_headers": request_headers,
            "request_body": request_body_str,
            "client_ip": client_ip,
            "request_time": datetime.utcnow(),
        }
        log_ids = logger.log_request(log_data)

        # Process the request
        try:
            response = await call_next(request)
            response_body = b""
            async for chunk in response.body_iterator:
                response_body += chunk
            response_body_str = sanitize_data(response_body.decode("utf-8", errors="ignore") if response_body else None)

            # Update log with response details
            execution_time_ms = int((time.time() - start_time) * 1000)
            response_data = {
                "response_status": response.status_code,
                "response_body": response_body_str,
                "response_headers": json.dumps(dict(response.headers)),
                "response_time": datetime.utcnow(),
                "execution_time_ms": execution_time_ms,
            }
            logger.log_response(log_ids, response_data)

            # Add IDs to response headers
            headers = dict(response.headers)
            headers["X-Request-ID"] = str(request_id)
            if correlation_id:
                headers["X-Correlation-ID"] = correlation_id
            if track_id:
                headers["X-Track-ID"] = track_id

            return JSONResponse(
                status_code=response.status_code,
                content=json.loads(response_body_str) if response_body_str else None,
                headers=headers,
            )

        except Exception as e:
            execution_time_ms = int((time.time() - start_time) * 1000)
            response_data = {
                "response_status": 500,
                "error_message": str(e),
                "response_time": datetime.utcnow(),
                "execution_time_ms": execution_time_ms,
            }
            logger.log_response(log_ids, response_data)
            raise HTTPException(status_code=500, detail="Internal Server Error")
Changes:
	•	Added uuid.uuid4() to generate request_id.
	•	Extracted correlation_id and track_id from headers.
	•	Included IDs in log_data and response headers.
3. `api_tracker/logging_strategies.py`
Update to handle the new fields.
from abc import ABC, abstractmethod
from sqlalchemy.orm import Session
from .models import APILog, RequestBody, ResponseBody
from .config import settings
import json
from datetime import datetime
import time

class LoggingStrategy(ABC):
    @abstractmethod
    def log_request(self, log_data: dict, db: Session = None) -> int:
        pass

    @abstractmethod
    def log_response(self, log_id: int, response_data: dict, db: Session = None):
        pass

class DatabaseLoggingStrategy(LoggingStrategy):
    def __init__(self, db: Session):
        self.db = db

    def log_request(self, log_data: dict, db: Session = None) -> int:
        log_entry = APILog(
            request_id=log_data["request_id"],
            correlation_id=log_data["correlation_id"],
            track_id=log_data["track_id"],
            request_method=log_data["request_method"],
            request_url=log_data["request_url"],
            request_headers=log_data["request_headers"],
            client_ip=log_data["client_ip"],
            request_time=log_data["request_time"],
        )
        self.db.add(log_entry)
        self.db.flush()

        if log_data.get("request_body"):
            request_body = RequestBody(api_log_id=log_entry.id, body=log_data["request_body"])
            self.db.add(request_body)

        self.db.commit()
        return log_entry.id

    def log_response(self, log_id: int, response_data: dict, db: Session = None):
        log_entry = self.db.query(APILog).filter(APILog.id == log_id).first()
        if log_entry:
            for key, value in response_data.items():
                if key != "response_body":
                    setattr(log_entry, key, value)

            if response_data.get("response_body"):
                response_body = ResponseBody(api_log_id=log_id, body=response_data["response_body"])
                self.db.add(response_body)

            self.db.commit()

class FileLoggingStrategy(LoggingStrategy):
    def log_request(self, log_data: dict, db: Session = None) -> int:
        log_id = int(time.time() * 1000)
        log_data["id"] = log_id
        log_data["request_id"] = str(uuid.UUID(bytes=log_data["request_id"]))  # Convert to string for JSON
        with open(settings.LOG_FILE_PATH, "a") as f:
            log_data["request_time"] = log_data["request_time"].isoformat()
            f.write(json.dumps(log_data) + "\n")
        return log_id

    def log_response(self, log_id: int, response_data: dict, db: Session = None):
        log_data = {"id": log_id, **response_data}
        with open(settings.LOG_FILE_PATH, "a") as f:
            if log_data.get("response_time"):
                log_data["response_time"] = log_data["response_time"].isoformat()
            f.write(json.dumps(log_data) + "\n")

class LoggingContext:
    def __init__(self, db: Session = None):
        self.strategies = []
        self.db = db
        for strategy in settings.LOGGING_STRATEGIES:
            if strategy.strip().lower() == "db" and db:
                self.strategies.append(DatabaseLoggingStrategy(db))
            elif strategy.strip().lower() == "file":
                self.strategies.append(FileLoggingStrategy())

    def log_request(self, log_data: dict) -> list[int]:
        log_ids = []
        for strategy in self.strategies:
            log_id = strategy.log_request(log_data, self.db)
            log_ids.append(log_id)
        return log_ids

    def log_response(self, log_ids: list[int], response_data: dict):
        for strategy, log_id in zip(self.strategies, log_ids):
            strategy.log_response(log_id, response_data, self.db)
Changes:
	•	Added request_id, correlation_id, and track_id to APILog instantiation.
	•	Converted request_id to string for file logging (JSON doesn’t support binary).
4. `api_tracker/schemas.py`
Update the Pydantic schema to include the new fields.
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
import uuid

class RequestBodyBase(BaseModel):
    id: int
    api_log_id: int
    body: Optional[str] = None

class ResponseBodyBase(BaseModel):
    id: int
    api_log_id: int
    body: Optional[str] = None

class APILogBase(BaseModel):
    id: int
    request_id: uuid.UUID
    correlation_id: Optional[str] = None
    track_id: Optional[str] = None
    request_method: str
    request_url: str
    request_headers: Optional[str] = None
    response_status: Optional[int] = None
    response_headers: Optional[str] = None
    client_ip: str
    request_time: datetime
    response_time: Optional[datetime] = None
    execution_time_ms: Optional[int] = None
    user_id: Optional[int] = None
    error_message: Optional[str] = None

    class Config:
        from_attributes = True
Changes:
	•	Added request_id, correlation_id, and track_id with appropriate types.
5. `tests/test_main.py`
Update tests to verify the new IDs.
import pytest
import pytest_asyncio
from fastapi import FastAPI
from httpx import AsyncClient
from api_tracker.main import add_api_logging_middleware
from api_tracker.database import get_db
from unittest.mock import Mock, patch
from datetime import datetime
import uuid

app = FastAPI()
add_api_logging_middleware(app)

async def mock_get_db():
    db = Mock()
    yield db

app.dependency_overrides[get_db] = mock_get_db

@pytest_asyncio.fixture
async def client():
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client

@pytest.mark.asyncio
async def test_logging_middleware_success(client, monkeypatch):
    monkeypatch.setattr("api_tracker.config.settings.EXCLUDED_PATHS", ["/other"])
    monkeypatch.setattr("api_tracker.config.settings.LOGGING_STRATEGIES", ["db"])
    async def test_endpoint():
        return {"message": "Test", "password": "secret"}
    app.get("/test")(test_endpoint)
    with patch("api_tracker.logging_strategies.LoggingContext.log_request") as mock_log_request, \
         patch("api_tracker.logging_strategies.LoggingContext.log_response") as mock_log_response:
        response = await client.get("/test", headers={"X-Correlation-ID": "corr-123", "X-Track-ID": "track-456"})
        assert response.status_code == 200
        assert "X-Request-ID" in response.headers
        assert response.headers["X-Correlation-ID"] == "corr-123"
        assert response.headers["X-Track-ID"] == "track-456"
        assert mock_log_request.called
        assert mock_log_response.called
        log_data = mock_log_request.call_args[0][0]
        assert isinstance(uuid.UUID(bytes=log_data["request_id"]), uuid.UUID)
        assert log_data["correlation_id"] == "corr-123"
        assert log_data["track_id"] == "track-456"
        assert log_data["request_method"] == "GET"
        assert log_data["request_url"] == "/test"

@pytest.mark.asyncio
async def test_logging_middleware_excluded(client, monkeypatch):
    monkeypatch.setattr("api_tracker.config.settings.EXCLUDED_PATHS", ["/health"])
    async def health_endpoint():
        return {"status": "healthy"}
    app.get("/health")(health_endpoint)
    with patch("api_tracker.logging_strategies.LoggingContext.log_request") as mock_log:
        response = await client.get("/health")
        assert response.status_code == 200
        assert not mock_log.called

@pytest.mark.asyncio
async def test_logging_middleware_error(client, monkeypatch):
    monkeypatch.setattr("api_tracker.config.settings.EXCLUDED_PATHS", ["/other"])
    async def failing_endpoint():
        raise ValueError("Test error")
    app.get("/fail")(failing_endpoint)
    with patch("api_tracker.logging_strategies.LoggingContext.log_request") as mock_log_request, \
         patch("api_tracker.logging_strategies.LoggingContext.log_response") as mock_log_response:
        response = await client.get("/fail")
        assert response.status_code == 500
        assert "X-Request-ID" in response.headers
        assert mock_log_request.called
        assert mock_log_response.called
        response_data = mock_log_response.call_args[0][1]
        assert response_data["response_status"] == 500
        assert response_data["error_message"] == "Test error"
Changes:
	•	Added header checks for X-Request-ID, X-Correlation-ID, and X-Track-ID.
	•	Verified IDs in log_data.

Notes
	•	UUID Handling: request_id is stored as RAW(16) in Oracle and converted to bytes in Python. For file logging, it’s stringified to fit JSON.
	•	Header Propagation: IDs are echoed back in response headers for traceability, a common practice in distributed systems.
	•	Flexibility: correlation_id and track_id are optional and can be any string up to their length limits, not strictly UUIDs.
This updated design enhances traceability and debugging capabilities. Let me know if you’d like further refinements (e.g., adding these IDs to other tables, stricter validation)!
